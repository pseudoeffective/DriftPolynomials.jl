# Tools for drawing drift configurations
# David Anderson, June 2025.


# updated to use integer matrices
# "O" => 0
# "+" => 1
# "/" => 2
# "%" => 3
# "|" => 4
# "-" => 5
# "." => 6
# "*" => 7
# "" => 8
# "o" => 9

using BumplessPipeDreams


export _intmtx2tuplemtx

"""
    draw_drift( d::Drift;
              mode::Symbol=:plots,
              saveto::String="none", 
              img_size::Tuple{Int,Int}=(300,300), 
              visible::Bool=true,
              unit=0.7,
              show_grid=true )

Display the drift configuration `d`, and optionally save it to an image file `saveto`.

## Arguments
- `d::Drift`: a drift configuration
- `mode::Symbol`: either `:plots` or `:ps`, generating an image or LaTeX-compatible PSTricks commands, respectively
- `saveto::String`: the filename, with suffix specifying format.  (E.g., .png, .pdf)  Default is "none" for no file saved.
- `img_size`: an ordered pair specifying the image size.
- `visible::Bool`: toggle whether the plot is displayed.  Default to `true`.
- `unit::Float`: set size of unit in PSTricks (for :ps mode)
- `show_grid`: display background grid (for :ps mode)

## Returns
-a plot object (in :plot mode)
or
-a LaTeX snippet (in :ps mode)


## Example
```julia-repl
# Generate a Drift plot
julia> dmtx = Int8[ 8 8 8 ; 8 0 8 ; 8 8 1 ]; d = Drift(dmtx)

· · · 
· □ · 
· · + 

julia> draw_drift( d; saveto="dc.png" )

# To get a PSTricks snippet, specify the mode=:ps
julia> draw_drift( d; mode=:ps, saveto="dc.tex" )
"%% Auto-generated by draw_drift\n\\psset{unit=0.7cm,linewidth=0.8pt}\n\\begin{pspicture}(0,0)(3,3)\n\\psline[linecolor=lightgray] (0,1)(3,1)\n\\psline[linecolor=lightgray] (0,2)(3,2)\n\\psline[linecolor=lightgray] (1,0)(1,3)\n\\psline[linecolor=lightgray] (2,0)(2,3)\n\\psline[linecolor=gray](0,0)(3,0)(3,3)(0,3)(0,0)\n\\psframe*[linecolor=orange!30] (1.00,1.00)(2.00,2.00)\n\\psline[linecolor=orange] (1.00,1.00)(2.00,1.00)(2.00,2.00)(1.00,2.00)(1.00,1.00)\n\\psline[linecolor=blue] (2.50,0.00)(2.50,1.00)\n\\psline[linecolor=blue] (2.00,0.50)(3.00,0.50)\n\\end{pspicture}\n"
```
"""
function draw_drift( d::Drift;
              kwargs... )

    draw_bpd(d; kwargs...)

end



# extend draw_bpd to Drift
function BumplessPipeDreams.draw_bpd(B::Drift;
                  saveto::String = "none",
                  mode::Symbol = :plots,
                  kwargs...)

    Bmtx = _intmtx2tuplemtx(B.mtx)

    if mode == :plots
        plots_loaded = isdefined(Main, :Plots) && Main.Plots isa Module
    
        if plots_loaded
            return BumplessPipeDreams._draw_bpd_plots(Bmtx; saveto=saveto, kwargs...)
        else
            error("mode :plots requires Plots to be loaded. Run 'using Plots' first.")
        end

    elseif mode == :ps
        tex = _draw_drift_pstricks(Bmtx; kwargs...)
        saveto != "none" && open(saveto, "w") do io; print(io, tex) end
        return tex
    else
        error("mode must be :plots or :ps")
    end
end


# --- helper ----------------------------------------------------
coord(a,b) = @sprintf("(%.2f,%.2f)", a, b)   # 2 decimals


function _draw_drift_pstricks(Bmtx::Matrix{<:Union{Int8,Tuple}}; unit=0.7, show_grid=true)
    n,m = size(Bmtx)
    io = IOBuffer()

    println(io, "%% Auto-generated by draw_drift")
    println(io, "\\psset{unit=$(unit)cm,linewidth=0.8pt}")
    println(io, "\\begin{pspicture}(0,0)($(m),$(n))")

    # light grid
    if show_grid
        for k in 1:n-1
            println(io, "\\psline[linecolor=lightgray] (0,$k)($m,$k)")
        end
        for k in 1:m-1
            println(io, "\\psline[linecolor=lightgray] ($k,0)($k,$n)")
        end
    end

    # outer frame
    println(io, "\\psline[linecolor=gray](0,0)($m,0)($m,$n)(0,$n)(0,0)")


    # tiles
    for i in 1:n, j in 1:m
        y, x = n - i, j - 1          # picture coords
        aa   = Bmtx[i,j]

        # helper shortcuts
        rect()  = println(io, "\\psframe*[linecolor=orange!30] $(coord(x,y))$(coord(x+1,y+1))")
        rectbord() = println(io, "\\psline[linecolor=orange] $(coord(x,y))$(coord(x+1,y))$(coord(x+1,y+1))$(coord(x,y+1))$(coord(x,y))")
        vline() = println(io, "\\psline[linecolor=blue] $(coord(x+0.5,y))$(coord(x+0.5,y+1))")
        hline() = println(io, "\\psline[linecolor=blue] $(coord(x,y+0.5))$(coord(x+1,y+0.5))")
        darkrect() = println(io, "\\psframe[linecolor=orange!30,fillstyle=crosshatch,hatchcolor=black!30] $(coord(x,y))$(coord(x+1,y+1))")

        plus()  = (vline(); hline())

        if aa == 0                         # orange box
         rect()
         rectbord()

        elseif aa == 1                     # "+"
         plus()

        elseif aa == 6         # dot
         println(io,
            "\\psdot[linecolor=blue,dotsize=4pt] $(coord(x+0.5,y+0.5))")

        elseif aa == 7      # blocked
            rect()
            darkrect()
            rectbord()

        elseif isa(aa, Tuple)              # labeled drift cell
         length(aa)>2 ? (rect(); darkrect()) : rect()
         rectbord()
            label, red = aa
            col = red ? "red" : "black"
        
         if red
            println(io,
            "\\rput[c]$(coord(x+0.5,y+0.5)){\\textcolor{$col}{\\bf$label}}")
         else 
            println(io,
            "\\rput[c]$(coord(x+0.5,y+0.5)){\\textcolor{$col}{$label}}")
         end

        end
    end


    println(io, "\\end{pspicture}")
    return String(take!(io))
end


# helper: convert int mtx to tuple
function _int2tuple(a::Integer)::Union{Int8,Tuple}
    if a<10
        return Int8(a)
    elseif a<100
        return (a-10,false)
    elseif a>=100 && a<1000
        return (a-100,true)
    elseif a>=1000 && a<2000
        return (a-1000,false,0)
    else
        return (a-2000,true,0)
    end
end

function _intmtx2tuplemtx(mtx::Matrix{<:Integer})
   return Union{Int8,Tuple}[ _int2tuple(a) for a in mtx]
end
    
        
